continue
next
exit
next
node
node.data
next
ordered
queue
next
queue[0]
next
curr_node.right_child.data
curr_node.left_child.data
curr_node
ordered
next
curr_node
next
curr_node
node.data
node
queue[0.data]
queue[0]
queue
exit
node
exit
node
exit
next
node
node.right_child.nil?
node.data
next
node.right_child.nil?
node
node.data
value
next
node.data
value
next
value
exit
node
value
vallue
node.data
next
exit
next
value
exit
root
next
exit
back
root
new_node
next
exit
root
root == nil
root
next
root
new_node
next
new_node
curr_node
next
exit
curr_node
new_node
next
step
exit
next
continue
next
exit
next
exit
next
curr_node
new_node
next
@root
next
new_node
curr_node
next
curr_node
next
curr_node
next
new_node
curr_node
next
curr_node
next
enxt
exit
eit
new_node
enw_node
curr_node
exit
@root
new_node
curr_node
next
new_node
@root
curr_node
exit
curr_node
new_node
exit
new_node == curr_node
new_node > curr_node
new_node < curr_node
curr_node
new_node
next
exit
curr_node
exit
new_node
curr_node
exit
new_node
curr_node
exit
curr_node
new_node
exit
new_node
curr_node
exit
new_node < curr_node
new_node > curr_node
new_node == curr_node
new_node = curr_node
new_node > curr_node
new_node < curr_node
curr_node
new_node
exit
@root
curr_node
next
enxt
curr_node
new_node
exit
new_node >  @root
new_node < @root
new_node < root
@root > new_node
@root
new_node
next
node
next
node
next
node
next
node
next
node
next
exit
node
next
node
next
enxt
node
next
node
next
node
next
node
next
node
next
node
next
node
next
node
next
right_arr
arr
next
arr
next
arr
next
arr
(1 / 2)
1 / 2
arr[mid+1..last].length - 1
arr
arr[mid+1..last]
arr
last = arr.length - 1
mid
last
first
arr[mid+1..last]
arr
last
mid
right_arr
arr
next
arr
next
arr
next
arr
next
arr
next
arr
next
arr
next
arr
next
arr
next
arr
next
arr
next
exit
arr
node
next
exit
node
arr
next
node
next
node
arr
next
arr
next
